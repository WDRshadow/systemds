#-------------------------------------------------------------
#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#
#-------------------------------------------------------------

#-------------------------------------------------------------
# This is a simple example for the use of the ResNets. Here,
# ResNet18 is used. Random data is used to only showcase the
# usage of the ResNets and their implemented utility functions.
# There are utility functions for different optimizers. To
# switch the used optimizer, comment and uncomment the
# corresponding lines marked with '***' in the initialization
# and training sections.
#-------------------------------------------------------------

source("scripts/nn/networks/resnet_util.dml") as resnet_util;
source("scripts/nn/networks/resnet18.dml") as resnet18;
source("scripts/nn/layers/softmax.dml") as softmax;
source("scripts/nn/layers/cross_entropy_loss.dml") as cross_entropy;
source("nn/optim/adam.dml") as adam;

# Parameters
num_images = 1000;
image_height = 32;  # Typical size for this example
image_width = 32;
num_channels = 3;  # For RGB images
num_classes = 10;  # Number of classes for this example

# Generate a random matrix of test images
# Each row represents a flattened image
X = rand(rows=num_images, cols=image_height * image_width * num_channels, min=0, max=255);

# Model initialization
[model, ema_means_vars] = resnet18::init(num_classes, -1);

# Initialize the output vector to store inferred classes
y_pred = matrix(0, rows=num_images, cols=num_classes);

# Define the forward pass function using the resnet18 model
forward = function(matrix[double] img, int image_height, int image_width, int num_channels, list[unknown] model, list[unknown] ema_means_vars)
    return (matrix[double] probs) {
    # Reshape the image to the original dimensions
    img_reshaped = matrix(0, rows=num_channels, cols=image_height * image_width);
    for (c in 1:num_channels) {
        img_reshaped[c,] = img[(c-1)*image_height*image_width + 1 : c*image_height*image_width];
    }
    img_reshaped = t(img_reshaped);

    # Perform the forward pass
    [out, ema_means_vars_upd, cached_out, cached_means_vars] = resnet18::forward(img_reshaped, image_height, image_width, model, "test", ema_means_vars);

    # Apply softmax to get probabilities
    probs = softmax::forward(out);
}

# Perform parallel scoring using parfor
parfor (i in 1:num_images) {
    # Get the ith image
    img = X[i,];

    # Perform forward pass to get the probabilities
    probs = forward(img, image_height, image_width, num_channels, model, ema_means_vars);

    # Store the probabilities in the output vector
    y_pred[i,] = probs;
}

# Print the first element of the output y_pred
print("First element of y_pred:");
print(toString(y_pred[1,]));

# Store the predicted probabilities
write(y_pred, "predicted_probabilities.csv", format="csv");

# End of the DML script
